<!DOCTYPE html>
<html>
<head>
    <title>Build A The Web</title>
    <meta name="description" content="We're going to learn you how to build a the web" />
    <meta name="author" content="Curtis Lassam" />

    <meta charset="UTF-8"/>
    <link rel="stylesheet" type="text/css" href="style.css">

    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">

    <!-- this script converts straight-quotes into proper directional quotes -->
    <script src="js/smartquotes.js"></script>
    <script>smartquotes()</script>

    <!-- jQuery -->
    <!--
    <script src="js/jquery-3.2.1.min.js"></script>

    <script src="js/buildATheWeb.tableOfContents.js"></script>
    -->
</head>

<body>

<div class="main" id="content">
    <h1> Build A The Web </h1>

    <h2> Introduction </h2>

    <p>
        This is <strong>Build A The Web</strong>, a book devoted to taking us, people with
        basic programming and computer knowledge, and upgrading us into web programmers.
    </p>

    <p>
        This is <strong class='book_version'>Version 0.1 &ndash; Drafty Old House</strong>
        of the book.
    </p>
    <p>
        It was last updated <strong class='book_last_update'>May 15, 2017</strong>.
    </p>

    <p>
        This book is available for free, under the terms of the
        <a href="https://www.gnu.org/licenses/agpl-3.0.en.html">GNU Affero General Public License v3.0 </a>, except
        for the fonts, which are available under the
        <a href="http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=OFL">Open Font License</a>.
    </p>
    <div class='right-aside-arrow'> </div>
    <div class='right-aside aside'>
        <h4>GPLv3</h4>
        <p>
            While Richard Stallman may appear to be a bit of a dogmatic screwball,
            the man's seemingly
            <a href='http://www.osnews.com/story/25469/Richard_Stallman_Was_Right_All_Along'>
            able to predict the future</a>.
        </p>
    </div>

    <p>
        This site, and all of the resources used to generate this site, including class materials
        and examples, are available at
        <a href="https://github.com/classam/buildatheweb">https://github.com/classam/buildatheweb</a>.
    </p>

    <h2 id="Chapter1lequestResponse"> Chapter 1: Request, Response </h2>

    <p>
        Our first chapter is going to focus on what happens behind the scenes when we make
        a web request. What that means is a crash course in computer networking.
    </p>

    <h3> Uniform Resource Locators </h3>

    <p>
        Let's start by looking at what happens when we crack open a web browser and
        type in:
    </p>

    <pre class='code'>https://en.wikipedia.org/w/index.php?title=Blinkenlights&amp;action=edit#Etymology</pre>

    <p> This is a <strong>URL</strong>, which stands for <strong>Uniform Resource Locator</strong>.</p>

    <div class='left-aside-arrow'> </div>
    <div class='left-aside aside'>
        <h4>URI</h4>
        <p>
        Some people might also call this an URI, but if we encounter a person who does this,
        I recommend that we shun then socially until they stop. </p>
    </div>


    <p>
        This URL uniquely identifies a document somewhere on someone else's
        computer that we are going to request from that computer.
    </p>

    <p>
        This divides into protocol, domain name, path, parameters,
        fragment, locus, and spindle. Memorize all of these terms now.
    </p>

    <div class='figure'>
        <h3> Dissecting a URL </h3>

        <h4>Protocol</h4>
        <p class='code'>
            <strong>https</strong>://en.wikipedia.org/w/index.php?title=Blinkenlights&amp;action=edit#Etymology
        </p>
        <p>
            The protocol describes <strong>how</strong> to connect.
        </p>

        <h4>Domain Name</h4>
        <p class='code'>
            https://<strong>en.wikipedia.org</strong>/w/index.php?title=Blinkenlights&amp;action=edit#Etymology
        </p>
        <p>
            The domain name describes <strong>where</strong> to connect to.
        </p>

        <h4>Path</h4>
        <p class='code'>
            https://en.wikipedia.org<strong>/w/index.php</strong>?title=Blinkenlights&amp;action=edit#Etymology
        </p>
        <p>
            The path describes <strong>what</strong> is being requested.
        </p>

        <h4>Parameters</h4>
        <p class='code'>
        https://en.wikipedia.org/w/index.php<strong>?title=Blinkenlights&amp;action=edit</strong>#Etymology
        </p>
        <p>
            The parameters describes <strong>extra arguments</strong> for the thing being requested.
        </p>

        <h4>Fragment</h4>
        <p class='code'>
            https://en.wikipedia.org/w/index.php?title=Blinkenlights&amp;action=edit<strong>#Etymology</strong>
        </p>

        <h4>Locus &amp; Spindle</h4>
        <p class='code'>
            the locus and spindle were in your <strong>heart</strong> the entire time
        </p>
    </div>

    <p>This is just a bunch of words, describing where we think our document is. How do we actually
        <strong>get</strong> that document?</p>

    <h2> Transport Control Protocol / Internet Protocol </h2>

    <p> Communicating with a far away computer is a process fraught with interesting problems. Problems like: </p>

    <ul>
        <li>How do we make sure that messages reliably arrive?</li>
        <li>How do we make sure that messages arrive in the right order?</li>
        <li>How does our computer communicate with our router?</li>
        <li>How does our router communicate with our modem?</li>
        <li>How do we get messages to travel across a thin strip of copper, or fiberoptic cable, at all?</li>
    </ul>

    <p>
        Most of these problems are quite complicated &mdash; and the lower level we get, the more likely it is
        that we'll need to consult an electrical engineer to explain signal processing theory to us.
        Believe me, that is the <em>last</em> thing that we want.
    </p>

    <p>
        Fortunately, smart people have already solved most of these problems for us.
        The solutions to these problems stack up on top of another &mdash; at the bottom, electrical engineers
        figuring out how to send messages across wires, at the top, math PhDs figuring out how to make sure
        that messages arrive reliably in a fixed order.
    </p>

    <p>
        We have two protocols at the very top of the stack that define how we communicate between computers &mdash;
        <strong>IP</strong>,
        the <strong>Internet Protocol</strong>, which defines how we send messages across the network,
        and <strong>TCP</strong>, the <strong>Transport Control Protocol</strong>, which makes sure that
        our messsages completely arrive, in the right order, and uncorrupted.
    </p>

    <h3> Protocol &amp; Stack</h3>

    <p>
        I'm going to say the word <strong>protocol</strong> a lot, and it's
        probably important that I establish what that means. In Computing Science,
        we learn the difference between an algorithm and a program &mdash;
        an algorithm describes a specific way of solving a problem,
        whereas a program is the actual code that we need to run the algorithm.
        We could have five different programs, all implementing the same algorithm.
    </p>

    <p> <strong>A protocol is an algorithm for communication</strong>. It delineates the rules of communication. </p>

    <div class='right-aside-arrow'> </div>
    <div class='right-aside aside'>
        <p>
            <strong>C&ndash;3P0</strong> was a protocol droid, because he was programmed with all of the rules
            for communicating with the various different cultures in the Galaxy Far Far Away. </p>
        </p>
        <p> Canonically, C-3P0 was also <em>not very good at this</em>. </p>
    </div>

    <p>
        In the same way that a program is an implementation of an algorithm, a
        <strong>stack</strong> is an implementation of a protocol.
        A protocol is an algorithm, and a stack is a program to implement a protocol.
        So, in order to run TCP/IP, our computer runs the TCP/IP stack, which implements the TCP/IP protocol. </p>

    <div class='left-aside-arrow'> </div>
    <div class='left-aside aside'>
        <p>
            It has come to my attention that computer people use the word "stack" too often.
        </p>
        <p>
            I keep trying to advance "pile" as an alternative, but it's not taking off.
        </p>
    </div>

    <h3> IP Address &amp; Sockets </h3>

    <p>
        The abstraction presented by TCP/IP is simple: every computer has an IP address.
        An IP address looks like this: <code>192.0.2.0</code> &mdash; or, like this:
        <code>2001:DB80:c501:17ef:a063:a37f:3803:5c1a</code>. These are just
        identifiers that communicate a unique identity for the computer in question.
    </p>

    <p>
        If we know our IP address, and the IP address of the computer that we want to
        communicate with, and that other computer is online, we can trust that IP will
        get the message to that computer. We can use TCP to open a <strong>socket</strong> to a specific
        <strong>port</strong> on our target computer.
    </p>

    <div class='figure'>
        <h3>Giant Walls of Plugs</h3>
        <img src="images/ports.png" />
        <p>
            Imagine these computers like giant walls of plugs &mdash; or ports &mdash; and when we open a connection,
            TCP creates a two way communication link between two ports with a socket on each end.
        </p>
    </div>

    <p>
        There are thousands of these ports &mdash; they're numbered from 1 to 65,535. In order to keep things tidy,
        each different protocol that runs on top of TCP usually runs on a different port.
        Of course, most computers aren't communicating on all of these ports at once &mdash;
        in fact, there are six ports that, on most computers, get more use than all
        of the rest of them combined:
    </p>

    <ul>
        <li><strong>25</strong>, for the Simple Mail Transfer Protocol (SMTP) </li>
        <li><strong>53</strong>, for the Domain Name System (DNS) </li>
        <li><strong>67</strong> and <strong>68</strong> for the Dynamic Host Configuration Protocol (DHCP) </li>
        <li><strong>80</strong> for the Hypertext Transfer Protocol (HTTP)</li>
        <li><strong>443</strong>, for the Hypertext Transfer Protocol over Transport Layer Security (HTTPS)</li>
    </ul>

    <p> We're going to cover all of these protocols in detail at one point or another. </p>

    <p> For every port that we could contact on a remote computer, there's a program on the remote
        computer that's running, listening, and potentially responding to our requests. </p>

    <h4> Server vs. Client </h4>
    <p>
        A computer that stays connected to the internet all of the time and responds to these
        requests is called a server, and server programming is half of the battle of web programming.
        The second half is client programming, which describes the parts
        of the transaction that occur on the customer's side of things.
    </p>

    <div class='right-aside-arrow'> </div>
    <div class='right-aside small-aside aside'>
        <p>
            The third half of the battle is <strong>lasers</strong>.
        </p>
    </div>

    <h3> DHCP </h3>
    <p>
        In order to communicate with a remote server, then, we need three things &mdash;
        our IP, their IP, and a port number, to communicate with.
    </p>
    <p>
        First of all, let's talk about how we got <strong>our IP Address</strong>.
    </p>
    <p>
        Well, the short answer is, our computer already knows its IP address. We just ask.
    </p>
    <p>
        How did our computer get its IP address? Well, when we connected it to the router &mdash;
        either via WiFi or by plugging it in &mdash; it communicated to the router, using
        <strong>DHCP</strong>, the <strong>Dynamic Host Configuration Protocol</strong>, where
        our computer asked the router to assign it an IP Address.
    </p>
    <p>
        Then, how did the router get its IP address? Well, when we connected the router to the
        internet, either by plugging it in to a modem or by plugging it in to another link in
        the network, it also communicated to a router, and communicated using DHCP.
        <em>"What is my IP?"</em>
    </p>

    <div class='left-aside-arrow'> </div>
    <div class='left-aside small-aside aside'>
        <p>
            How did that router get its IP? Magic. It was magic.
        </p>
    </div>

    <h3>Network Address Translation</h3>

    <p> If we ask our computer to tell us its IP address, it'll probably report something
        that starts with <code>10.0</code> or <code>192.168</code> &mdash; but, if we go to
        Google and ask <em>"what is my IP?"</em>,
        it'll tell us a completely different IP address. </p>

    <p> What gives? How can our computer have more than one IP address? </p>

    <p>
        As part of our deal with our Internet Service Providers, we usually get just one IP address.
        Just the one. Presumably, we have more than one device in our home &mdash; a computer, a cel phone,
        a laptop, a second computer, a smart TV, a toaster that connects to the internet for some reason,
        a third computer, a toothbrush that connects to the internet for some reason,
        things have really gone out of control lately.
    </p>

    <p>
        All of these devices need to share the one IP address, so, our router creates a little private
        network, just for us, in our home. In this private network, any computer can have any IP address
        that it wants. By convention, the IPs for use in private networks start with <code>192.168</code>
        or <code>10.0</code>. Then, when we're connecting to the outside world, our router translates
        our IP address in the private network into our public IP address.
    </p>

    <p>
        This is <strong>NAT</strong>, <strong>Network Address Translation</strong>.
    </p>

    <div class='figure'>
        <p>The router creates a private network for all of our devices and
            assigns them local IP addresses. </p>
        <img src='images/nat_1.png'>
        <p>When our devices make requests to the internet, the router
            translates them into the public-facing IP address. </p>
        <img src='images/nat_2.png'>
        <p>When the internet responds, the router remembers who requested
            the content and forwards the response back to that IP address. </p>
        <img src='images/nat_3.png'>
    </div>


    <h3>Domain Name System</h3>

    <p> In order to communicate with a server, we need both our own IP address and the IP address
        of the computer that we want to communicate with. </p>

    <p> We have our own IP address &mdash; now we need to find the address of the server that we
        want to talk to. </p>

    <p> Let's look at the link we're trying to access. </p>

    <p class='code'>
        https://<strong>en.wikipedia.org</strong>/w/index.php?title=Blinkenlights&amp;action=edit#Etymology
    </p>

    <p>
        There's no IP address anywhere in this link. There <strong>is</strong> a domain name,
        <code>en.wikipedia.org</code>
    </p>

    <p>
        In order to find the IP address for this server, we're going to have to start by consulting
        a DNS server. <strong>DNS</strong> stands for <strong>Domain Name System</strong>,
        and the process of converting a domain name into an IP address is called
        <strong>name resolution</strong>.
    </p>

    <p>
        How do we know where the DNS server is? When we use DHCP to connect to WiFi, it
        also provides us with the IP of the nearest DNS server, which is usually being maintained
        by our ISP. Acronyms!
    </p>

    <div class='figure'>
        <h3>Turkish Protesters</h3>
        <img src="https://thumbs.mic.com/OTRlYzcwMmFjNyMvaFd2UmRLalRLejgzRUVlMGlfaXdRZVdrSWdNPS8weDI4OjU5Mng0MDEvMTYwMHg5MDAvZmlsdGVyczpmb3JtYXQoanBlZyk6cXVhbGl0eSg4MCkvaHR0cHM6Ly9zMy5hbWF6b25hd3MuY29tL3BvbGljeW1pYy1pbWFnZXMvZGFhMmMyNDQ1NGQxYmI2OThhZjY3Yzc2ZjNlOTM2MzZmZmUxYzViMzMxYmFhZDk3NzM2ZmZjMjExZTk3MzI2OS5qcGc.jpg">
        <p>
            Google also maintains a public DNS server at the address <code>8.8.8.8</code>, which is good to know
            in case our local DNS server ever goes down or is
            <a href="https://mic.com/articles/85987/turkish-protesters-are-spray-painting-8-8-8-8-and-8-8-4-4-on-walls-here-s-what-it-means#.x2HgXBndh">interfered with by a totalitarian government</a>.
        </p>
    </div>

    <p>
        So our computer sends a request to the DNS server, asking where to find <code>en.wikipedia.org</code>.
    </p>

    <p>
        If the server already knows where <code>en.wikipedia.org</code> is, then it responds with the
        IP address. Let's imagine, though, that the server doesn't know.
    </p>

    <div class='right-aside-arrow'> </div>
    <div class='right-aside small-aside aside'>
        <h3>howdns.works</h3>
        <a href="https://howdns.works/"><img src="images/dns_root.png"></a>
        <p> The best way to understand DNS is to visit <a href='https://howdns.works/'>howdns.works</a>,
            where they illustrate the protocol with fun cartoons. </p>
    </div>

    <p>
        DNS Root servers are distributed all over the globe, and they keep track of
        exactly one thing: the IP addresses of the computers reponsible for the
        recordkeeping of top level domains, like
        <ul>
            <li><code>.com</code></li>
            <li><code>.net</code></li>
            <li><code>.org</code></li>
            <li><code>.photo</code></li>
            <li><code>.click</code></li>
            <li><code>.ninja</code></li>
            <li><code>.unicorn</code></li>
            <li><code>.fun</code></li>
            <li><code>.ooo</code></li>
            <li><code>.plumbing</code></li>
            <li><code>.oh my god top level domains are just getting dumber and dumber</code></li>
        </ul>
    </p>

    <p>
        So, the DNS server looks at the domain name we've given it &mdash;
        <code>en.wikipedia.org</code> &mdash;
        sends a request to the root server, and asks
        <em>"which servers can I ask about .org records?"</em>
    </p>

    <p>
        The root server will reply with a list of IP addresses responsible
        for .org records. These are the addresses of <strong>Top Level Domain Servers</strong>,
        which are maintained by <strong>Domain Registrars</strong>.
        We can pay these people about ten US dollars a year to
        create and maintain a record for us,
        so long as nobody else has claimed that domain name already.
        For a pittance, I now own http://butts.work.
    </p>

    <div class='left-aside-arrow'> </div>
    <div class='left-aside aside'>
        <p>
            Some people claim that the <strong>most important tool in web programming</strong>
            is a command line or a text editor,
            but I will maintain that it is a <strong>credit card</strong>.
    </div>

    <p>
        Finally, the DNS server queries the wikipedia nameservers, asking them
        where they can find <code>en</code>.
        If we paid a registrar to put up a domain name for us,
        they'll usually throw in a nameserver for free &mdash;
        all we have to do is write some DNS rules that tell the nameserver what
        IP we want to point at.
    </p>

    <p>
        DNS rules are written in a cryptic language that contains records
        with names like <code>A</code>, <code>MX</code>, <code>AAAA</code>,
        and <code>AAAAAAAAAAAAAAAAHH SPIDERS</code> &mdash;
        I'm sorry, there was a spider next to the keyboard.
    </p>

    <p>
        So, Wikipedia's nameservers report that en.wikipedia.org is
        located at, say, <code>203.0.113.98</code>.
        Finally, after that entire protracted process, we know where wikipedia is.
    </p>

    <div class='right-aside-arrow'> </div>
    <div class='right-aside small-aside aside'>
        <p>
            Because I wrote this in the <em>past</em>, that's bound
            to change and has definitely changed already.
        </p>
    </div>

    <h3>Hypertext Transfer Protocol</h3>

    <p>
        Our next step is to use TCP/IP to create a connection between our
        IP address, and the IP address that we just resolved from DNS.
    </p>

    <p>
        There's only one thing left that we need &mdash; a port number.
        We also didn't specify a port number as part of the URL,
        but we did specify a protocol,
        <strong>HTTPS</strong> &mdash;
        the <strong>HyperText Transfer Protocol feat. Transport Layer Security</strong> &mdash;
        and when we specify a protocol without a port number,
        our connection automatically goes to the default port for that protocol.
        In the case of HTTPS, that's <strong>443</strong>.
    </p>

    <p>
    The <strong>Hypertext Transfer Protocol (HTTP)</strong> is the protocol responsible
        for moving documents around. Request a document? Get a document.
        The rules for that are laid out in the Hypertext Transfer Protocol,
        which is the protocol that powers pretty much the entire web as we know it.
    </p>

    <p>
        Our URL is HTTP<strong>S</strong>, though, not just HTTP. The difference is slight
        but important &mdash; HTTPS is the same as HTTP, but over a connection encrypted
        with <strong>Transport Layer Security (TLS)</strong>.
        This prevents J. Random Hacker from watching every HTTP request that goes by.
    </p>
    <div class='right-aside-arrow'> </div>
    <div class='right-aside aside'>
        <p>
            Transport Layer Security is a form of
            <a href="https://www.youtube.com/watch?v=jkV1KEJGKRA">End to End Encryption</a>.
        </p>
    </div>

    <div class='left-aside-arrow'> </div>
    <div class='left-aside aside'>
        <p>
            <strong>J. Random Hacker</strong> is an arbitrary
            programmer.

            <blockquote cite="http://www.catb.org/jargon/html/appendixb.html">
            A mythical figure like the Unknown Soldier; the archetypal hacker nerd.
                <a class='citation' href="http://www.catb.org/jargon/html/appendixb.html">The Jargon File</a>
            </blockquote>
        </p>
    </div>

    <p>
        Once we've created this encrypted communication path between our computer
        and the faraway server, we need to construct a HTTP Request. It'll look
        something like this:
    </p>

    <pre class='code'>
GET /w/index.php?title=Blinkenlights&amp;action=edit#Etymology HTTP/1.1
Host: en.wikipedia.org</pre>

    <p>
        This is a request to <code>GET</code> whatever's at the path
        of the URL we provided to our browser.
    </p>

    <p>
        It also includes <strong>Headers</strong> with the request &mdash; sets of key
        and value that communicate extra information to the server. In this case,
        the only header we've included is "Host".
    </p>

    <p>
        The server will receive this request, and respond with a HTTP Response
        containing the sweet webpage we've been looking for this entire time.
    </p>

    <p>
        Virtually everything in web programming happens in the space between
        the HTTP request and the HTTP response. Figuring out how to respond,
        quickly,
        with the right stuff is the meat and potatoes of web programming.
        This bit, right here. It's all the marbles. Empires have risen
        and fallen, all dependant on the simple gap of how a server converts
        this HTTP request into a HTTP response.
    </p>

    <p>
        And then, Wikipedia responds. The full HTTP response is several
        pages long, we can look at it <a href='wikipedia_http_response'>here</a>.
        In order to keep my book neat and tidy, though, I'm going to
        concoct a fake response for the sake of example:
    </p>

    <pre class='code'>
HTTP/1.1 200 OK
Content-language: en
Content-type: text/html; charset=UTF-8
X-Clacks-Overhead: GNU Terry Pratchett

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;Definitely Wikipedia&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;This is totally Wikipedia.&lt;/h1&gt;
&lt;p&gt; Hi there. I am Bob Wikipedia and you are at my website.
It&rsquo;s still under construction but I am pretty sure it will be done by 1998.&lt;/p&gt;
&lt;img src=&rdquo;https://media0.giphy.com/media/K5Yn9JCXcrXr2/giphy.gif&rdquo;/&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

    <p>
        It opens with the version of HTTP that's currently running,
        as well as a <strong>HTTP Status Code</strong>.
        So long as the HTTP Status Code is <code>200 OK</code> we're good to go.
    </p>

    <div class='figure'>
        <h3>A Brief And Mostly Inaccurate Reference Chart for HTTP Status Codes</h3>
        <img src="images/247.png">
        <p>
            A more accurate look at HTTP status codes can be found
            <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">here</a>.
        </p>
        <p>
            Alternatively, pictures of cats matching every HTTP status code exist
            at <a href="http://http.cat">http.cat</a>.
        </p>
    </div>

    <p>
        After the HTTP version and status code, there are <strong>Headers</strong>
        again. These headers describe important properties of the file that's
        been returned.
    </p>

    <pre class='code'>
Content-language: en
Content-type: text/html; charset=UTF-8
X-Clacks-Overhead: GNU Terry Pratchett</pre>

    <p>
        Most headers are defined in the <a href='https://tools.ietf.org/html/rfc2616'>HTTP protocol</a>, but we can add
        any headers that we want by starting them with <code>X-</code>,
        which is how we can sneak in <a href='http://www.gnuterrypratchett.com/'>the clacks</a>.
    </p>

    <p>
        After the HTTP version and status code, we get into a big patch
        of HTML. How do we know that it's HTML? Well, the <code>Content-type</code>
        header referred to this as <code>text/html</code>, so we can be
        pretty sure that we've got a big handful of HTML.
    </p>

    <h3> Hypertext Markup Language </h3>

    <p>
        I'm going to do a dramatic reading of a passage from
        "In The Beginning Was The Command Line".
        Despite being almost 20 years old, it's a stonkingly accurate
        diatribe on computer culture and a fun historical record from
        <em>the before times</em>.
    </p>

    <blockquote cite="http://artlung.com/smorgasborg/C_R_Y_P_T_O_N_O_M_I_C_O_N.shtml">
        <p>
            This crud is called <strong>HTML (HyperText Markup Language)</strong>
            and it is basically
            a very simple programming language instructing your web browser how
            to draw a page on a screen. Anyone can learn HTML and many people do.
            The important thing is that no matter what splendid multimedia
            web pages they might represent, HTML files are just telegrams.
        </p>

        <p>
            When Ronald Reagan was a radio announcer, he used to call baseball
            games by reading the terse descriptions that trickled in over the
            telegraph wire and were printed out on a paper tape. He would sit there,
            all by himself in a padded room with a microphone, and the paper
            tape would eke out of the machine and crawl over the palm of
            his hand printed with cryptic abbreviations. If the count went
            to three and two, Reagan would describe the scene as he saw it
            in his mind's eye: "The brawny left-hander steps out of the
            batter's box to wipe the sweat from his brow. The umpire steps
            forward to sweep the dirt from home plate." and so on.
            When the cryptogram on the paper tape announced a base hit,
            he would whack the edge of the table with a pencil, creating
            a little sound effect, and describe the arc of the ball as if
            he could actually see it. His listeners, many of whom presumably
            thought that Reagan was actually at the ballpark watching the game,
            would reconstruct the scene in their minds according to his descriptions.
        </p>

        <p>
            This is exactly how the World Wide Web works: the HTML files are
            the pithy description on the paper tape,
            and your Web browser is Ronald Reagan.
        <p>

        <a class='citation' href='http://artlung.com/smorgasborg/C_R_Y_P_T_O_N_O_M_I_C_O_N.shtml'>
            Neal Stephenson, "In The Beginning Was The Command Line"
        </a>

    </blockquote>

    <div class='right-aside-arrow'> </div>
    <div class='right-aside aside'>
        <p>
            As of 2004, only 5 years after the original publication,
            Neil Stephenson regarded it as badly out of date.
        </p>
        <p>
            Another author, with permission, published an
            <a href="http://garote.bdmonkeys.net/commandline/index.html">annotated version</a>.
        </p>
        <p>
            The annotations are now even more badly out of date.
        </p>
    </div>

    <p>
        So, the HTML that Wikipedia has returned to us contains a description of
        the content that we're looking at, and then our web browser
        renders it into a webpage.
    </p>

    <p>
        It would seem like, here, our journey is complete.
        We've made a round trip between our device and the server, and we're done
        &mdash; but, not quite! When the browser renderer gets to this part of the HTML:
    </p>

    <pre class='code'>
&lt;img src=&rdquo;https://media0.giphy.com/media/K5Yn9JCXcrXr2/giphy.gif&rdquo;/&gt;</pre>

    <p>
        This image tag references content that exists at another URL.
        And so, we kick off this entire process again, from start to finish,
        to get whatever it is at that new address. The trick is, though,
        instead of sending us HTML, this server will respond with an animated image.
        Modern web-pages may require dozens of requests to various images
        and scripts before they're completely rendered.
    </p>

    <h3>Summary</h3>

    <p>Every browser request&ndash;response goes a little something like this: </p>

    <ul>
        <li>Our browser uses <strong>DNS</strong> to resolve the <strong>URL</strong>'s
            domain into an <strong>IP</strong> address. </li>
        <li>Our browser uses <strong>TCP</strong> to create a two-way connection with the
            server at that IP address. </li>
        <li>If the URL's protocol is <strong>HTTPS</strong>, then a
            <strong>TLS</strong> connection is made to the server.</li>
        <li>Our browser sends a <strong>HTTP request</strong> to the server. </li>
        <li>The server does some stuff. </li>
        <li>A <strong>HTTP response</strong> is sent back to us, containing a document. </li>
        <li>If that document is <strong>HTML</strong>, the browser will render that HTML
            into a webpage. </li>
        <li>If that document contains other URLs, the browser will create new requests
            for each of them. </li>
    </ul>


    <h2> Chapter 2: Hello, World </h2>

    <p>Theory is fun, but do you know what would be more fun? </p>

    <p>Getting a server up and running!</p>

    <p>By tradition, when computering, our first program is always a program to print
        out 'hello, world'. </p>

    <div class='figure'>
        <img src='images/tattoo_1.jpg' alt='hello world, being tattooed on my arm'/>
        <p>
            You could, of course, broadcast the message "hello, world" by tattooing
            it on your arm, as I have, but perhaps we should start with a less
            permanent solution to the problem.
        </p>
    </div>

    <div class='right-aside-arrow'> </div>
    <div class='right-aside aside'>
        <h3>Hello, world</h3>
        <p>
            "Hello, world" is important to me (as you might have guessed), as a symbol
            of learning by starting small.
        </p>
        <p>
            Even experienced programmers start with "hello, world" in a new environment.
            It's a great way to make sure that everything is configured properly.
        </p>
        <p>
            The tradition started with Brian Kernighan at Bell Labs, with the introduction
            of the C Language.
        </p>
    </div>

    <p>
        We're going to be doing everything &mdash; absolutely everything &mdash; from
        a Linux command line.
    </p>

    <p>
        Both of these choices &mdash; Linux, and the command line &mdash; might seem
        a little strange. Let's dig into them a bit.
    </p>

    <div class='left-aside-arrow'> </div>
    <div class='left-aside aside'>
        <h3>GNU/Linux</h3>
        <p>
            <a href="https://www.gnu.org/gnu/why-gnu-linux.en.html">Some people</a>
            believe that Linux should be called "GNU/Linux", on account of
            Linux was partially built using tools provided by the GNU project.
        </p>
        <p>
            However, if all things were named the way that they should be named,
            IKEA would be called "Garbage Furniture Store" and all sandwiches
            would be "Mayonnaise Sandwich" because without the mayonnaise they
            are not really sandwiches at all.
        </p>
    </div>

    <h3> Linux </h3>

    <p>
        Fully half of web programming is server programming. In order to program
        a server, we're going to need a server &mdash; a computer that stays online all
        the time and responds to client requests.
    </p>

    <p>
        We could use our home computer as a server, but:
        <ul>
            <li>Windows and Mac operating systems have an awkward tendency to
                reboot themselves to install security updates and add features,
                and this is not optional. </li>
            <li>A home computer has all of its security defaults set in a way
                that would be appropriate for a computer on a home network,
                not a computer exposed to the tireless onslaught of the
                public internet. </li>
            <li>Unless we pay our ISP extra for a static IP address, our
                home's IP address changes regularly, which means that it
                will be difficult to find our computer. </li>
            <li>Our home computer likely contains our own, personal, private information. </li>
            <li>Doing other stuff on our home computer, like opening 80 browser tabs
                while playing video games, could affect the performance of our server. </li>
    <div class='right-aside-arrow'> </div>
    <div class='right-aside small-aside aside'>
        <p>Only 80 tabs?</p>
        <p>You are like a little <strong>baby</strong>.</p>
    </div>
            <li> Unless we happen to have a home fibre connection, it's likely
                that we're on an asymmetric connection to the internet &mdash; with downloads
                <em>much</em> faster than uploads. For a server, though, it is the upload
                speed that matters; serving a lot of traffic from our home internet
                connection would be like trying to operate a Denny's through a foot-wide hole
                &mdash; possible, but frustrating once we have more than one or two customers.
            </li>
        </ul>
    </p>

    <p>
        These are not insurmountable problems, and building a home server out of a
        spare computer is a fun and instructive project that I highly recommend.
    </p>

    <p>
        With the home computer out as a server option, that leaves us renting server time
        from someone else.
    </p>

    <p>
        There are lots of reasons that we might choose Linux over Windows if we're
        planning on running a server for a long time. Linux is lightweight. Linux is secure.
        Linux is able to stay online for a very long time. The reason
        for Linux's popularity as a server is very simple, though: <strong>Linux is free</strong>,
        which generally makes server Linux the most cost-effective option.
    </p>

    <div class='right-aside-arrow'> </div>
    <div class='right-aside aside'>
        <h3>Free or Four</h3>
        <p>
            In software, there are two meanings of free.
        </p>

        <p>
            The first meaning is the obvious one, and the correct one:
            free means "we don't have to pay for it".
        </p>

        <p>
            But there's the other meaning of free, meaning the code
            is <em>wild and free like an unbroken stallion</em>.
            This is an alternative definition of free that has to do with
            our freedom to legally take the code, modify it as we please,
            and share it with others. Linux is also free in this way.
        </p>

        <p>
            Many systems are one kind of free but not another - GitHub, for example,
            is don't-have-to-pay free but not freeeeeeedom!-free, whereas Red Hat Linux
            is freeeedom!-free but we still have to pay money dollars for it.
        </p>
    </div>

    <h4>"It's a UNIX system! I know this!"</h4>

    <p>
        Linux, like Mac OS X, is based on Unix, an operating system with an
        almost half-century of history, only some of which involves
        <a href="https://www.wired.com/2015/06/tech-time-warp-time-unix-saved-day-jurassic-park/">velociraptors</a>.
        That half-century can be a double-edged
        sword &mdash; the reason for strange design decisions is often shrouded
        in some ancient
        <a href="http://ergoemacs.org/emacs/emacs_kb_shortcuts_pain.html">obscure keyboard layout</a>.
    </p>

    <div class='left-aside-arrow'> </div>
    <div class='left-aside aside'>
        <h3>Bell Labs &amp; Unix</h3>
        <p>
            If we're at all interested in computing history &mdash; and why
            wouldn't we be, it's the <em>best history</em> &mdash; we're
            going to hear Bell Labs come up a lot.
        </p>
        <p>
            It was created by Alexander Graham Bell in 1925, as the
            "Volta Laboratory and Bureau", a private research laboratory,
            and has changed hands numerous times since then.
        </p>
        <p>
            Since opening, the laboratory has been responsible for eight
            different Nobel prizes between 1937 and 2014 &mdash; which gives
            it more Nobel laureates than the University of British Columbia.
        </p>
        <p>
            Bell Labs invented transistors in the fifties, invented CCDs in 2009,
            and, in the sixties, discovered the cosmic background radiation that validated
            the existence of the Big Bang.
        </p>
        <p>
            Oh, and during a brief lull in the seventies, Bell Labs created
            Unix and C, the most successful operating system and
            programming language in the world.
        </p>
        <p> Way to go, Bell Labs. </p>

    </div>

    <h4>Linux Distributions</h4>
    <p>
        One confusing thing about Linux is that we can't just crack open a laptop
        and start running Linux on it &mdash; in fact, Linux really refers to
        <strong>The Linux Kernel</strong>, which is the tiny beating heart
        of the operating system.
    </p>
    <p>
        There are lots of things that we think of as part of an operating system
        &mdash; the window system, a desktop environment, the software that
        comes pre-installed on the system, device drivers, installers,
        Minesweeper &mdash; but the Linux Kernel doesn't come with any of these
        things.
    </p>

    <p>
        So, the complete kit required to make a computer actually do computer
        things is called a <strong>Linux Distribution</strong>.
    </p>

    <p>
        Popular distributions
        include <strong>Ubuntu</strong>, <strong>Red Hat/Fedora</strong>, <strong>Mint</strong>,
        <strong>Slackware</strong>, and <strong>Arch</strong>.
    </p>

    <p>
        Different distributions focus on different priorities.
        Some, like <strong>Mint</strong>, focus on being easy to use as a desktop OS.
        <strong>Arch</strong> is highly configurable and optimizable, and
        popular with the sort of people who drive a 1996 Nissan 300ZX Turbo
        with a gigantic aftermarket spoiler and undercar lights.
    </p>

    <div class='right-aside-arrow'> </div>
    <div class='right-aside aside'>
        <p>
            Gentoo is for the sort of people who would buy the Arch user's car,
            then take the aftermarket spoiler and lights off.
        </p>
    </div>

    <p>
        <strong>Ubuntu</strong> started out resolutely trying to conquer the
        desktop PC market, but after a decade of mostly failing to do so, has
        seemingly embraced its position as a competitive and pretty comprehensive
        server operating system. I like Ubuntu, a lot, and it's the
        distribution I'm going to be using as an example distribution.
    </p>

    <h3> The Command Line & The Secure Shell </h3>

    <p>
        Most systems work is still done with the command line.
    </p>

    <p>
        While I'd love to say that this is because the command line is
        inherently superior to all other methods of interaction
        with a computer, the actual reasons are simple:
        <ul>
            <li>It's easier to write a command line program than a GUI program. </li>
            <li>SSH</li>
        </ul>

    <div class='left-aside-arrow'> </div>
    <div class='left-aside aside'>
        <p>
            What's a librarian's favourite shell command? SSH.
        </p>
    </div>
    </p>

    <p>
        <strong>SSH</strong>, or <strong>Secure Shell</strong>,
        is one of the most important tools in our web programming arsenal.
        SSH is a tool allowing for remote control of computers.
    </p>
    <p>
        Most Linux distributions run the SSH daemon in the background, all the time,
        and it's possible to log in to the computer directly with a username and
        password.
    </p>
    <div class='right-aside-arrow'> </div>
    <div class='right-aside aside'>
        <p>
            <strong>Daemon</strong> is the Unix term for a program that runs in the background,
            without user intervention.
        </p>
        <p> Windows, perhaps wanting to divorce itself from the theological implications of
            having a legion of demons under the hood, calls these services instead. </p>
    </div>
    </p>

    <p>
        But the SSH interface to a Linux computer doesn't come with any fancy doodads
        or graphical user interfaces. Nope, dad-gummit, we have to control the system
        by pulling up our suspenders, tying an onion to our belts, walking uphill
        both ways, and using the command line interface.
    </p>

    <div class='left-aside-arrow'> </div>
    <div class='left-aside aside'>
        <p>
            And in those days, nickels had pictures of bumblebees on them. Give me five bees for a quarter, you'd say.
        </p>
        <p>
            Now where were we? Oh yeah, the important thing was that I had an onion on my belt, which was the style
            at the time. They didn't have white onions, becuase of the war. The only thing that you could
            get was those big yellow ones.
        </p>
    </div>

    <h3> Let's Get This Terrible Party Started </h3>

    <p>
        First and foremost, we are going to need access to a command line.
    </p>

    <p>
        If we're running Mac OS X, we can get to a command line, right now,
        by opening the "Terminal" program &mdash; although
        downloading <a href="https://www.iterm2.com/">iTerm2</a> gets us tabs and splits.
    </p>

    <div class='right-aside-arrow'> </div>
    <div class='right-aside aside'>
        <h3>Tabs &amp; Splits</h3>
        <p>
            When we work with terminals, sooner or later we're going to have 10 of them open
            at once. When this starts happening, having the ability to split them out
            into separate tabs starts to become <em>way convenient</em>.
        </p>
        <p>
            If you have a wide screen, it's also nice to be able to split the
            terminal in half and have <em>twice as many terminals</em>.
        </p>
    </div>

    <p>
        If we're running Windows, we can download <a href="https://git-scm.com/">Git</a>.
        We're going to need Git anyways, it's the most widely used source control
        tool on the market, but it also comes with the <em>easiest to configure unix-like console
        available in Windows</em>.
    </p>

    <div class='left-aside-arrow'> </div>
    <div class='left-aside small-aside aside'>
        <p>
            Yeah, move over, Cygwin.
        </p>
    </div>

    <p>
        If we're not in a hurry, we also might spend some time configuring
        <a href="https://conemu.github.io/">ConEmu</a> to
        <a href="https://gist.github.com/n3dst4/cc875d83401c06bd6faa">work with Git Bash</a>.
        This gets us the tabs and the splits.
    </p>
    <div class='right-aside-arrow'> </div>

    <h3> Installing Ubuntu </h3>
    <p>
        This used to be a process that involved either running both Ubuntu and Windows/Mac OS X
        on our primary computer, and switching from one to the other when we boot
        up the computer &mdash; or, finding a junky old computer from around the house
        and installing Ubuntu on that.
    </p>
    <div class='left-aside-arrow'> </div>
    <div class='left-aside aside'>
        <p>
            There's also
            <a href="https://msdn.microsoft.com/en-us/commandline/wsl/about">Bash on Ubuntu on Windows Subsystem for Linux</a>, which
            is a new and exciting way to install Ubuntu on Windows, but it's
            still <em>very beta</em>.
        </p>
    </div>
    <p>
        With Virtual Machines, though, it's possible to run Ubuntu from within our primary operating
        system. So we should definitely do that.
        In fact, the toolset for doing this has become so easy to use that I've started
        running a <em>different virtual machine for every project I'm working on</em>.
    </p>
    <div class='right-aside-arrow'> </div>
    <div class='right-aside small-aside aside'>
        <p>
            I built a computer with 32GB of RAM just to make this practical, although
            I could also <em>just remember to turn the virtual machines off once in a while</em>.
        </p>
    </div>

    <p>
        The tools that make this easy and free are <a href="https://www.virtualbox.org/">VirtualBox</a>
        and <a href="https://www.vagrantup.com/">Vagrant</a>. Download and install these programs.
    </p>

    <h3>Code Directory & Project Root</h3>
    <p>
        Somewhere on our computer is our <strong>home directory</strong>. This is the root
        for all of our personal files. In Windows, my home directory lives at
        <code>C:\Users\Curtis</code>, whereas in Mac OS X, the home directory lives
        in <code>/users/curtis</code>.
    </p>

    <p>
        I'm fond of creating a directory, <code>code</code>, under the home root, as
        my project root. Every different project I'm working on lives in this directory.
        Then, I configure my terminal to open this directory when it starts up.
    </p>

    <p>
        Let's open our terminal &mdash; be it Terminal, iTerm2, Git Bash, or ConEmu.
    </p>

    <div class='right-aside-arrow'> </div>
    <div class='right-aside small-aside aside'>
        <h3> Shell Game </h3>
        <p>
            Technically, the <strong>terminal</strong> is the window that shows you
            the <strong>shell</strong>, which is the program that actually handles
            your interactions with the command prompt.
        </p>
        <p>
            <strong>Bash</strong> is the Bourne Again Shell, the most common shell
            for Linux systems.
        </p>
        <p>
            <strong>SSH</strong> is the Secure Shell, a shell to remote systems.
        </p>
        <p>
            <strong>sh</strong> stands for "Shell", and it refers to whatever
            is the default shell on a system.
        </p>
        <p>
            <strong>dash</strong> is a lightweight shell without the features
            and functionality of Bash. In Debian and Ubuntu, <code>/bin/sh</code>
            points to dash instead of bash, but bash is still the default shell
            for users.
        </p>
    </div>

    <div class='figure'>
        <img src='images/chapter2/terminal_1.png' />
        <p>dat's some good terminal</p>
    </div>

    <p>
        We're staring a <strong>command prompt</strong> in the face. That <code>$</code>
        means that the terminal is ready for us to enter a command.
    </p>

    <h3>Let's Putter Around In The Terminal A Bit</h3>

    <p>
        I'm excited! I get to tell you about the <strong>most important</strong> shell commands!
    </p>

    <p>
        Let's start by asking where we are, using the <strong>print working directory</strong> command,
        <code>pwd</code>.
    </p>

    <pre class='code'>
<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code</span>
<span class='prompt'>$</span> pwd
/c/Users/curtis/code</pre>


    <h4> Tilde Swinton</h4>

    <p>
        So, we're at <code>/c/Users/curtis/code</code>, but the terminal says that
        we're at <code>~/code</code>. What's the deal?
    </p>

    <p>
        <code>~</code> is shorthand for "home".
        Since our home is <code>/c/Users/curtis</code>, <code>~/code</code>
        is shorthand for <code>/c/Users/curtis/code</code>.
    </p>

    <h4> MSYS </h4>
    <p>
        Follow-up question: why is it <code>/c/Users/curtis/code</code>
        and not <code>C:\Users\curtis\code</code>?
    </p>

    <p>
        Simulating Bash on Windows requires a layer to translate Windows concepts
        into vaguely-Linux-shaped concepts. This is provided by MinGW &mdash; Minimalist GNU for Windows
        &mdash; and MSYS, which is a collection of utilities like Bash ported to run on MinGW.
    </p>

    <p>
        Linux doesn't support lettered-drive roots like <code>C:</code>, instead prefering
        to have a single root for all drives, <code>/</code>.
        Linux also uses forward slashes instead of backslashes.
    </p>

    <p>
        MSYS and MinGW do this conversion for us, but the differences between Windows
        and Linux are going to continue to bite us all the way throughout this journey.
    </p>

    <p>
        Mac OS X, being built on top of a Unix system called "Darwin", doesn't suffer from
        these problems.
    </p>

    <h4>Terminal Commands</h4>

    <p>
        Using the <strong>change directory</strong> command, <code>cd</code>, we can change
        our directory.
    </p>

    <pre class='code'>
<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code</span>
<span class='prompt'>$</span> cd ~

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~</span>
<span class='prompt'>$</span> pwd
/c/users/curtis
</pre>

    <p> Look, we're home, now! </p>

    <p> We can navigate directly to a specific directory: </p>

    <pre class='code'>
<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~</span>
<span class='prompt'>$</span> cd /

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>/</span>
<span class='prompt'>$</span> cd /etc

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>/etc</span>
<span class='prompt'>$</span>
</pre>

    <p> And we can use <code>ls</code> to display the contents of a directory: </p>

    <pre class='code'>
<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>/etc</span>
<span class='prompt'>$</span> cd ~

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~</span>
<span class='prompt'>$</span> ls
AppData
Application Data
ConEmu
Contacts
Cookies
Creative Cloud Files
Embarrassing Pornography
Even More Embarrassing Pornography
Seriously, Goats and Stuff
Desktop
Documents
Music
NTUSER.DAT
_vim
_viminfo
_vimrc
code
pip
vimfiles
</pre>

    <p>Whoa. There's a lot of stuff in my home directory.</p>

    <p>If there's no code directory in here, yet, we can make one, with <code>mkdir</code></p>

    <pre class='code'>
<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~</span>
<span class='prompt'>$</span> mkdir code
mkdir: cannot create directory 'code': File exists
</pre>

    <p>That doesn't work, because in my case, the code directory already exists. </p>

    <p>Here's a good trick. Type in <code> cd c</code> and then hit the tab key.</p>

    <pre class='code'>
<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~</span>
<span class='prompt'>$</span> cd code

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code</span>
<span class='prompt'>$</span>
    </pre>

    <p>The terminal should auto-complete to the first thing that starts with a 'c'. If you press tab again, it'll
        auto-complete to the second thing that starts with a 'c'. This is a very useful tool. </p>

    <div class='figure'>
        <p>All this computer hacking is making me thirsty. I think I'll order a TAB.</p>

        <img src="http://i.imgur.com/rIePs33.jpg">

        <div class='right-aside-arrow'> </div>
        <div class='right-aside aside'>
            <p><em>This is a reference to a joke from an episode of The Simpsons that is now over 20 years old,
            referencing a brand of diet cola that is only sold in the United States and Spain</em></p>
        </div>
    </div>

    <p> Let's create a directory for our hello world program. </p>

    <pre class='code'>
<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code</span>
<span class='prompt'>$</span> mkdir hello_world

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code</span>
<span class='prompt'>$</span> ls
hello_world
    </pre>

    <p> Now let's delete that directory and then recreate it, just to be contrary. </p>

    <pre class='code'>
<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code</span>
<span class='prompt'>$</span> rmdir hello_world

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code</span>
<span class='prompt'>$</span> ls

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code</span>
<span class='prompt'>$</span> mkdir hello_world

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code</span>
<span class='prompt'>$</span> ls
hello_world
    </pre>

    <p> We can use <code>cd</code> to jump in to the folder we've just created, and we can also
        use <code>cd</code> with the special shortcut <code>..</code> to go up a level. </p>

    <pre class='code'>
<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code</span>
<span class='prompt'>$</span> cd hello_world

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code/hello_world</span>
<span class='prompt'>$</span> cd ..

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code</span>
<span class='prompt'>$</span> cd ..

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/</span>
<span class='prompt'>$</span>
hello_world
    </pre>

    <p> That feels like a pretty solid introduction to the command line. With these simple
        tools we can zip around the filesystem creating directories like a pro!</p>

    <div class='figure'>
        <h4>Curtis's Big Sexy Terminal Top Eight Commands</h4>
        <table>
            <tr>
                <th><code>ls</code></th> <td> list the contents of a directory </td>
            </tr>
            <tr>
                <th><code>cd</code></th> <td> change the directory </td>
            </tr>
            <tr>
                <th><code>pwd</code></th> <td> tell me what directory I'm in </td>
            </tr>
            <tr>
                <th><code>mkdir</code></th> <td> make a directory </td>
            </tr>
            <tr>
                <th><code>rmdir</code></th> <td> remove a directory </td>
            </tr>
            <tr>
                <th><code>touch</code></th> <td> make a file </td>
            </tr>
            <tr>
                <th><code>cat</code></th> <td> print a file </td>
            </tr>
            <tr>
                <th><code>rm</code></th> <td> remove a file </td>
            </tr>
        </table>
    </div>

    <h3>Vagrant</h3>

    <p>We installed Vagrant and VirtualBox, earlier. What are these for?</p>

    <p>
        Well, VirtualBox is software to run virtual machines. We could get away with
        just using VirtualBox in our quest to install Ubuntu, but that would take
        a lot of effort and clicking.
    </p>

    <p>
        Vagrant is a wrapper around VirtualBox that provides a very hackable
        command line interface and a gigantic repository of pre-created
        operating system images. Installing an operating system with Vagrant
        can be as easy as just picking it out of a catalogue and modifying a text
        file.
    </p>

    <p>
        One of the things I like most about Vagrant is that it's possible to configure
        the entire operating system automatically. Instead of laboriously hand-configuring
        the operating system every time we move to a new machine or accidentally bork
        a database, we can just scour the virtual machine clean and summon a new one.
    </p>

    <p>Let's go back to our new 'hello_world' directory and type in <code>vagrant init</code></p>

    <pre class='code'>
<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code</span>
<span class='prompt'>$</span> cd hello_world

<span class='machine'>curtis@SMOKESTACK</span> <span class='path'>~/code/hello_world</span>
<span class='prompt'>$</span> vagrant init
A `Vagrantfile` has been placed in this directory. You are now
ready to `vagrant up` your first virtual environment! Please
read the comments in the Vagrantfile as well as documentation
on `vagrantup.com` for more information on using Vagrant.
    </pre>

    <p><code>vagrant init</code> creates for us a <strong>Vagrantfile</strong>. This file
        describes all of the important details about the operating system we are about
        to create &mdash; which Linux distribution we want, networking details, how much
        RAM it gets to use, and even, if we configure it right, the instructions for
        setting up all of the software that runs on the operating system.</p>

    <p>Now it's time to open up the Vagrantfile in a text editor. </p>

    <!-- TODO: this bit, here -->

    <!-- not until we get to nginx configuration modifications -->

    <h3> A Different Kind of Text Editor </h3>

    <p>
        Presumably, we're far enough along in the craft of programming to know that a
        text editor is the software developer's multi-tool, and one's choice of text editor
        is approximately as emotionally charged and contentious as one's choice of video
        game console.
    </p>
    <div class='right-aside-arrow'> </div>
    <div class='right-aside small-aside aside'>
        <p>
            TurboGrafx 16 forever!
        </p>
    </div>

    <p>
        But there's a problem &mdash; because we're going to be working extensively with SSH,
        and SSH is a command shell, with no mouse to speak of, we're going to need
        a text editor that operates entirely from within the shell.
    </p>

    <p>
        This leaves us, then, with about three different options:
        <ul>
            <li><strong>vim</strong>, my favourite, which is cryptic and difficult, but powerful</li>
            <li><strong>emacs</strong>, which is even more cryptic and difficult, but even more powerful</li>
            <li><strong>nano</strong>, which is quite easy to learn, but offers limited functionality</li>
        </ul>
    </p>

    <div class='figure'>
        <h4>Nano is Like a Spork</h4>
        <img src='images/chapter2/198.png' />
    </div>

    <p class="ohno">
        <strong> Oh no! </strong> This is as far as I've written!
        Keep track of the <a href="https://github.com/classam/buildatheweb">project on GitHub</a> for updates!
    </p>

    <!--

    <h3>Linux</h3>

    <h3>The Command Line </h3>

    <h2> Chapter 3: Getting It Online </h2>

    -->
    <!--
    <h4> Fun DNS Hacks </h4>
    -->
    <!-- Upside Down Ternet, Cat DNS, log everything, create in-house name resolution -->
</div>
</body>

</html>
